from datetime import date
import pandas as pd
import numpy as np
from collections import defaultdict

from .exporters import is_source_image

from typing import Any, Dict, DefaultDict, List, Tuple

plt = None
matplotlib = None


def parse_asset_name(asset_name: str) -> Tuple[int, int, int, str]:
    split_vals = asset_name.split("_")

    return int(split_vals[0]), int(split_vals[1]), int(split_vals[2]), split_vals[3]


def features_to_df(features_dict: Dict) -> pd.DataFrame:
    r"""
    Return a pandas dataframe describing all the assets

    :param features_dict: A dictionary of the features, returned by
        mlhub.get_all_assets

    :returns: A dataframe with columns ["feature", "image_date", "bands"],
        describing the available data for each feature
    """
    features: List[str] = []
    dates: List[date] = []
    bands: List[str] = []

    for feature, f_dict in features_dict.items():

        for asset, asset_dict in f_dict.items():
            if is_source_image(asset):
                year, month, day, band = parse_asset_name(asset)

                features.append(feature)
                dates.append(date(year=year, month=month, day=day))
                bands.append(band)
    return pd.DataFrame({"feature": features, "image_date": dates, "bands": bands})


def check_dates_across_features(
    features_df: pd.DataFrame, check_all_bands: bool = True
) -> pd.DataFrame:
    r"""
    :param features_df: A dataframe with columns ["feature", "image_date", "bands"],
        generated by features_to_df
    :param check_all_bands: Whether or not to check for all the bands. If False, will
        only check for a single source image. Default = True.
    :returns: A dataframe with each feature as a column, and dates
        as an index. ``df[date, feature_name] == True`` if feature_name has data for
        that date, and false otherwise.
    """

    date_list: List[date] = []
    feature_complete: Dict[str, List[Any]] = defaultdict(list)
    all_features = features_df.feature.unique()
    all_bands = features_df.bands.unique()
    for unique_date in features_df.image_date.unique():
        date_list.append(unique_date)
        for feature in all_features:
            sub_df = features_df[
                (
                    (features_df.feature == feature)
                    & (features_df.image_date == unique_date)
                )
            ]

            if len(sub_df) == 0:
                feature_complete[feature].append(False)
            elif check_all_bands:
                feature_complete[feature].append(
                    len(sub_df.bands.unique()) == len(all_bands)
                )
            else:
                feature_complete[feature].append(True)
    feature_complete["image_date"] = date_list
    df = pd.DataFrame(feature_complete)
    df = df.set_index("image_date")
    return df


def plot_range(dates_df: pd.DataFrame) -> None:
    r"""To better visualize the distribution of data
    across features and dates.

    :param dates_df: A dataframe with each feature as a column, and dates
        as an index. ``df[date, feature_name] == True`` if feature_name has data for
        that date, and false otherwise. Generated by check_dates_across_features
    """

    global plt
    if plt is None:
        import matplotlib.pyplot as plt

    global matplotlib
    if matplotlib is None:
        import matplotlib

    sorted_df = dates_df.sort_index()

    plt.clf()  # type: ignore

    fig = plt.figure()  # type: ignore
    ax = fig.add_subplot(111)

    green = np.array([[0, 255, 0]])

    ax.imshow(
        np.expand_dims(sorted_df.values.astype(int).T, -1) * green,
        aspect="auto",
        interpolation="nearest",
    )
    ax.set_yticks(np.arange(len(sorted_df.columns)))
    ax.set_yticklabels(list(sorted_df.columns))
    ax.set_title("Data availability over time (Green means present)")
    ax.set_xticks(np.arange(len(sorted_df.index)))
    ax.set_xticklabels(list(sorted_df.index))

    for idx, label in enumerate(ax.xaxis.get_ticklabels()):
        if idx % 10 != 0:
            label.set_visible(False)
    fig.autofmt_xdate()

    plt.show()  # type: ignore
